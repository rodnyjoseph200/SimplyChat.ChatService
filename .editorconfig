# editorconfig
# Roslyn-analyzer-based code-style rules
# docs: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview?tabs=net-9
# docs: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options?source=recommendations
# docs: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/

root = true

# C# files
[*.cs]

###############################################
########## Core EditorConfig Options ##########
###############################################

# indent_size defines the number of spaces used for each indentation level.
indent_size = 4

# indent_style defines whether to use spaces or tabs for indentation.
indent_style = space

# tab_width sets the number of columns used to represent a tab character if indent_style=tab.
tab_width = 4

# end_of_line sets the line ending character(s) to use.
# Windows-friendly CRLF
# Different platforms might cause merge conflicts if mismatched
end_of_line = crlf

# insert_final_newline specifies whether to ensure the file ends with a newline.
insert_final_newline = false

#############################################
########## .NET Coding Conventions ##########
#############################################

# dotnet_separate_import_directive_groups controls whether using directives are separated into groups by blank lines.
dotnet_separate_import_directive_groups = false

# dotnet_sort_system_directives_first enforces whether 'System' namespaces come first in usings.
dotnet_sort_system_directives_first = true:warning

# file_header_template controls the file header text inserted in new files. 'unset' means no header is enforced.
file_header_template = unset

# dotnet_style_qualification_for_event enforces use of 'this.' qualifier for events.
# Example:
# [TRUE]
# this.eventHandler?.Invoke(this, EventArgs.Empty);
# [FALSE]
# eventHandler?.Invoke(this, EventArgs.Empty);
dotnet_style_qualification_for_event = false

# dotnet_style_qualification_for_field enforces use of 'this.' qualifier for fields.
# Example:
# [TRUE]
# this.myField = 10;
# [FALSE]
# myField = 10;
dotnet_style_qualification_for_field = false

# dotnet_style_qualification_for_method enforces use of 'this.' qualifier for methods.
# Example:
# [TRUE]
# this.DoSomething();
# [FALSE]
# DoSomething();
dotnet_style_qualification_for_method = false

# dotnet_style_qualification_for_property enforces use of 'this.' qualifier for properties.
# Example:
# [TRUE]
# this.MyProperty = 5;
# [FALSE]
# MyProperty = 5;
dotnet_style_qualification_for_property = false

# dotnet_style_predefined_type_for_locals_parameters_members specifies to use language keywords (int, string, etc.) instead of BCL types (Int32, String).
# Example:
# [TRUE]: int x = 0;
# [FALSE]: Int32 x = 0;
dotnet_style_predefined_type_for_locals_parameters_members = true

# dotnet_style_predefined_type_for_member_access specifies to use language keywords when accessing static members of a type.
# Example:
# [TRUE]: string.Empty
# [FALSE]: String.Empty
dotnet_style_predefined_type_for_member_access = true

# dotnet_style_parentheses_in_arithmetic_binary_operators enforces parentheses around arithmetic expressions for clarity.
# Example:
# Option 1: (a + b) * c
# Option 2: a + b * c
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity

# dotnet_style_parentheses_in_other_binary_operators enforces parentheses for other binary operators for clarity.
# Example:
# Option 1: (x & y) == 0
# Option 2: x & y == 0
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity

# dotnet_style_parentheses_in_other_operators controls parentheses usage for other operators like cast or unary operators.
# Example:
# Option 1: (int)x + 1
# Option 2: (int)x + (1)
dotnet_style_parentheses_in_other_operators = never_if_unnecessary

# dotnet_style_parentheses_in_relational_binary_operators enforces parentheses around relational operators for clarity.
# Example:
# Option 1: (a < b) == true
# Option 2: a < b == true
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity

# dotnet_style_require_accessibility_modifiers enforces accessibility keywords on certain members.
# Example:
# Option 1: public void MyMethod() { }
# Option 2: void MyMethod() { } 
dotnet_style_require_accessibility_modifiers = for_non_interface_members

# dotnet_style_coalesce_expression prefers '??' operator instead of conditional expressions for null checks.
# Example:
# [TRUE]: var result = value ?? "default";
# [FALSE]: var result = value != null ? value : "default";
dotnet_style_coalesce_expression = true:warning

# dotnet_style_collection_initializer enforces using collection initializers where possible.
# Example:
# [TRUE]: var list = new List<int> { 1, 2, 3 };
# [FALSE]
# var list = new List<int>();
# list.Add(1);
# list.Add(2);
# list.Add(3);
dotnet_style_collection_initializer = true

# dotnet_style_explicit_tuple_names ensures tuple fields have explicit names when declared.
# Example:
# [TRUE]: (int Id, string Name) person = (1, "John");
# [FALSE]: (int, string) person = (1, "John");
dotnet_style_explicit_tuple_names = true

# dotnet_style_namespace_match_folder enforces that namespaces match the folder structure.
# Example:
# [TRUE]
# (placed in folder MyProject/Utilities)
# namespace MyProject.Utilities { }
# [FALSE]: namespace SomeRandomName { }
dotnet_style_namespace_match_folder = true:warning

# dotnet_style_null_propagation prefers the null-conditional operator ?. over explicit null checks.
# Example:
# [TRUE]: var length = str?.Length;
# [FALSE]: var length = str == null ? null : str.Length;
dotnet_style_null_propagation = true:warning

# dotnet_style_object_initializer enforces using object initializers where possible.
# Example:
# [TRUE]: var person = new Person { Name = "Alice", Age = 30 };
# [FALSE]
# var person = new Person();
# person.Name = "Alice";
# person.Age = 30;
dotnet_style_object_initializer = true

# dotnet_style_operator_placement_when_wrapping sets the placement of operators when wrapping lines.
# Example:
# Option 1 (beginning_of_line):
# var sum = a
#     + b
#     + c;
# Option 2 (end_of_line):
# var sum = a +
#     b +
#     c;
dotnet_style_operator_placement_when_wrapping = end_of_line

# dotnet_style_prefer_auto_properties prefers auto-properties over properties with explicit backing fields.
# Example:
# [TRUE]
# public int Age { get; set; }
# [FALSE]
# private int _age;
# public int Age { get { return _age; } set { _age = value; } }
dotnet_style_prefer_auto_properties = true

# dotnet_style_prefer_collection_expression prefers the new collection expression form when types loosely match.
# Example:
# Option 1: var list = [ 1, 2, 3 ];
# Option 2: var list = new List<int> { 1, 2, 3 };
dotnet_style_prefer_collection_expression = when_types_loosely_match

# dotnet_style_prefer_compound_assignment prefers operators like += or *= over explicit expansions.
# Example:
# [TRUE]: x += 1;
# [FALSE]: x = x + 1;
dotnet_style_prefer_compound_assignment = true:warning

# dotnet_style_prefer_conditional_expression_over_assignment prefers conditional expressions instead of if statements for assignments.
# Example:
# [TRUE]: var result = condition ? "Yes" : "No";
# [FALSE]
# string result;
# if (condition) result = "Yes";
# else result = "No";
dotnet_style_prefer_conditional_expression_over_assignment = true:warning

# dotnet_style_prefer_conditional_expression_over_return prefers conditional expressions instead of if statements for returns.
# Example:
# [TRUE]: return condition ? "Yes" : "No";
# [FALSE]
# if (condition) return "Yes";
# return "No";
dotnet_style_prefer_conditional_expression_over_return = true:suggestion

# dotnet_style_prefer_foreach_explicit_cast_in_source sets the preference to cast the item in the foreach when the type is known.
# Example:
# Option 1:
# foreach (var x in collectionOfObjects.Cast<string>())
# { /* ... */ }
# Option 2:
# foreach (string x in collectionOfObjects)
# { /* ... */ } // May cause invalid cast exceptions if not actually strings
dotnet_style_prefer_foreach_explicit_cast_in_source = when_strongly_typed

# dotnet_style_prefer_inferred_anonymous_type_member_names prefers omitting property names if they match.
# Example:
# [TRUE]: var anon = new { FirstName, LastName };
# [FALSE]: var anon = new { FirstName = FirstName, LastName = LastName };
dotnet_style_prefer_inferred_anonymous_type_member_names = true

# dotnet_style_prefer_inferred_tuple_names prefers omitting tuple element names if they match.
# Example:
# [TRUE]: var person = (firstName, lastName);
# [FALSE]: var person = (firstName: firstName, lastName: lastName);
dotnet_style_prefer_inferred_tuple_names = true

# dotnet_style_prefer_is_null_check_over_reference_equality_method prefers using "is null" instead of ReferenceEquals(obj, null).
# Example:
# [TRUE]: if (obj is null) { ... }
# [FALSE]: if (ReferenceEquals(obj, null)) { ... }
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:warning

# dotnet_style_prefer_simplified_boolean_expressions prefers shorter boolean forms.
# Example:
# [TRUE]: if (flag) { ... }
# [FALSE]: if (flag == true) { ... }
dotnet_style_prefer_simplified_boolean_expressions = true:warning

# dotnet_style_prefer_simplified_interpolation prefers simpler string interpolation forms.
# Example:
# [TRUE]: $"Hello {name}"
# [FALSE]: $"Hello {name.ToString()}"
dotnet_style_prefer_simplified_interpolation = true:warning

# dotnet_style_readonly_field enforces using 'readonly' for fields that are never modified after construction.
# Example:
# [TRUE]: private readonly int _count = 0;
# [FALSE]: private int _count = 0;
dotnet_style_readonly_field = true

# dotnet_code_quality_unused_parameters configures how unused parameters are handled.
# Example:
# Option 1: method signature aligns with the interface even if parameter is unused
# Option 2: warns or errors if parameter is not used
dotnet_code_quality_unused_parameters = all

# dotnet_remove_unnecessary_suppression_exclusions controls which suppressions are considered unnecessary.
# Example:
# Option 1: none excludes no suppressions
# Option 2: could set to specific categories
dotnet_remove_unnecessary_suppression_exclusions = none

# dotnet_style_allow_multiple_blank_lines_experimental controls whether multiple consecutive blank lines are allowed.
# Example:
# [TRUE]: can have multiple blank lines
# [FALSE]: single blank lines only
dotnet_style_allow_multiple_blank_lines_experimental = false:warning

# dotnet_style_allow_statement_immediately_after_block_experimental controls whether statements can appear on the same line as a closing brace.
# Example:
# [TRUE]
# if (condition)
# {
#     DoSomething();
# } DoSomethingElse();
# [FALSE]
# if (condition)
# {
#     DoSomething();
# }
# DoSomethingElse();
dotnet_style_allow_statement_immediately_after_block_experimental = false:warning

###########################################
########## C# Coding Conventions ##########
###########################################

# csharp_style_var_elsewhere controls whether to use var for all variables, except built-in types or apparent cases.
# Example:
# [TRUE]: int x = 0;
# [FALSE]: var x = 0;
csharp_style_var_elsewhere = false

# csharp_style_var_for_built_in_types enforces the use of 'var' for built-in types.
# Example:
# [TRUE]: var x = 0;
# [FALSE]: int x = 0;
csharp_style_var_for_built_in_types = true:warning

# csharp_style_var_when_type_is_apparent enforces using 'var' when the type is obvious from the right side of the assignment.
# Example:
# [TRUE]: var stream = new MemoryStream();
# [FALSE]: MemoryStream stream = new MemoryStream();
csharp_style_var_when_type_is_apparent = true:warning

# csharp_style_expression_bodied_accessors enforces using expression bodies for accessors.
# Example:
# [TRUE]: public int Age => _age;
# [FALSE]: public int Age { get { return _age; } }
csharp_style_expression_bodied_accessors = true:silent

# csharp_style_expression_bodied_constructors enforces using expression bodies for constructors.
# Example:
# [TRUE]: public Person() => Name = "Unknown";
# [FALSE]
# public Person()
# {
#     Name = "Unknown";
# }
csharp_style_expression_bodied_constructors = true:silent

# csharp_style_expression_bodied_indexers enforces expression bodies for indexers.
# Example:
# [TRUE]: public int this[int index] => _items[index];
# [FALSE]
# public int this[int index]
# {
#     get { return _items[index]; }
# }
csharp_style_expression_bodied_indexers = true:suggestion

# csharp_style_expression_bodied_lambdas enforces using expression bodies for lambdas.
# Example:
# [TRUE]: var func = x => x * 2;
# [FALSE]
# var func = x =>
# {
#     return x * 2;
# };
csharp_style_expression_bodied_lambdas = true:suggestion

# csharp_style_expression_bodied_local_functions enforces using expression bodies for local functions.
# Example:
# [TRUE]: int Sum(int a, int b) => a + b;
# [FALSE]
# int Sum(int a, int b)
# {
#     return a + b;
# }
csharp_style_expression_bodied_local_functions = true:silent

# csharp_style_expression_bodied_methods enforces using expression bodies for methods.
# Example:
# [TRUE]: public int GetValue() => 42;
# [FALSE]
# public int GetValue()
# {
#     return 42;
# }
csharp_style_expression_bodied_methods = true:silent

# csharp_style_expression_bodied_operators enforces using expression bodies for operator overloads.
# Example:
# [TRUE]: public static Vector operator +(Vector a, Vector b) => new(a.X + b.X, a.Y + b.Y);
# [FALSE]
# public static Vector operator +(Vector a, Vector b)
# {
#     return new Vector(a.X + b.X, a.Y + b.Y);
# }
csharp_style_expression_bodied_operators = true:silent

# csharp_style_expression_bodied_properties enforces using expression bodies for properties.
# Example:
# [TRUE]: public int MyProperty => _myField;
# [FALSE]
# public int MyProperty
# {
#     get { return _myField; }
# }
csharp_style_expression_bodied_properties = true:suggestion

# csharp_style_pattern_matching_over_as_with_null_check prefers pattern matching instead of 'as' + null check.
# Example:
# [TRUE]: if (obj is MyClass c) { ... }
# [FALSE]
# var c = obj as MyClass;
# if (c != null) { ... }
csharp_style_pattern_matching_over_as_with_null_check = true:warning

# csharp_style_pattern_matching_over_is_with_cast_check prefers pattern matching over 'is' + cast.
# Example:
# [TRUE]: if (obj is MyClass c) { ... }
# [FALSE]
# if (obj is MyClass) { var c = (MyClass)obj; ... }
csharp_style_pattern_matching_over_is_with_cast_check = true:warning

# csharp_style_prefer_extended_property_pattern prefers using the extended property pattern in switch or if statements.
# Example:
# [TRUE]: if (obj is { Property: 10 }) ...
# [FALSE]: if (obj is MyClass { Property: 10 }) ...
csharp_style_prefer_extended_property_pattern = true

# csharp_style_prefer_not_pattern prefers 'not' pattern instead of '!' when matching conditions.
# Example:
# [TRUE]: if (obj is not null) { ... }
# [FALSE]: if (!(obj is null)) { ... }
csharp_style_prefer_not_pattern = true:warning

# csharp_style_prefer_pattern_matching prefers pattern matching expressions overall when possible.
# Example:
# [TRUE]: if (obj is MyClass c) { ... }
# [FALSE]: if (obj is MyClass) { var c = (MyClass)obj; ... }
csharp_style_prefer_pattern_matching = true:warning

# csharp_style_prefer_switch_expression prefers switch expressions over switch statements when possible.
# Example:
# [TRUE]: return input switch { 1 => "one", 2 => "two", _ => "other" };
# [FALSE]
# switch (input) { case 1: return "one"; case 2: return "two"; default: return "other"; }
csharp_style_prefer_switch_expression = true

# csharp_style_conditional_delegate_call prefers ?. syntax over null checks when invoking delegates.
# Example:
# [TRUE]: MyEvent?.Invoke(this, EventArgs.Empty);
# [FALSE]
# if (MyEvent != null) { MyEvent(this, EventArgs.Empty); }
csharp_style_conditional_delegate_call = true

# csharp_prefer_static_anonymous_function prefers marking anonymous functions as static when they don't capture outer variables.
# Example:
# [TRUE]: Func<int, int> sq = static x => x * x;
# [FALSE]: Func<int, int> sq = x => x * x;
csharp_prefer_static_anonymous_function = true

# csharp_prefer_static_local_function prefers marking local functions as static when they don't capture outer variables.
# Example:
# [TRUE]: static int Add(int a, int b) => a + b;
# [FALSE]: int Add(int a, int b) => a + b;
csharp_prefer_static_local_function = true

# csharp_preferred_modifier_order enforces the order of modifiers for types and members.
# Example:
# Option 1: public static int MyValue;
# Option 2: static public int MyValue; 
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async

# csharp_style_prefer_readonly_struct enforces 'readonly struct' for structures that do not mutate their state.
# Example:
# [TRUE]: public readonly struct MyStruct { ... }
# [FALSE]: public struct MyStruct { ... }
csharp_style_prefer_readonly_struct = true

# csharp_style_prefer_readonly_struct_member enforces 'readonly' on struct members where possible.
# Example:
# [TRUE]: public readonly int GetValue() => _value;
# [FALSE]: public int GetValue() => _value;
csharp_style_prefer_readonly_struct_member = true

# csharp_prefer_braces enforces using braces for if/else/for/while/etc.
# Example:
# [TRUE]
# if (condition)
# {
#     DoSomething();
# }
# [FALSE]
# if (condition) DoSomething();
csharp_prefer_braces = false:suggestion

# csharp_prefer_simple_using_statement enforces the C# 8+ simplified using statement.
# Example:
# [TRUE]
# using var file = new FileStream(...);
# [FALSE]
# using (var file = new FileStream(...)) { ... }
csharp_prefer_simple_using_statement = true:warning

# csharp_style_namespace_declarations enforces the namespace declaration style (file-scoped vs block-scoped).
csharp_style_namespace_declarations = file_scoped:warning

# csharp_style_prefer_method_group_conversion prefers using method groups over lambda expressions when they are equivalent.
# Example:
# [TRUE]: list.ForEach(Console.WriteLine);
# [FALSE]: list.ForEach(x => Console.WriteLine(x));
csharp_style_prefer_method_group_conversion = true:warning

# csharp_style_prefer_primary_constructors prefers using primary constructors where possible.
# Example:
# [TRUE]: public class Person(string name) { }
# [FALSE]: public class Person { public Person(string name) { } }
csharp_style_prefer_primary_constructors = false:suggestion

# csharp_style_prefer_top_level_statements prefers top-level statements over explicit Program class.
csharp_style_prefer_top_level_statements = true:suggestion

# csharp_prefer_simple_default_expression prefers the 'default' literal over explicit type or constructor calls.
# Example:
# [TRUE]: default
# [FALSE]: default(int)
csharp_prefer_simple_default_expression = true:warning

# csharp_style_deconstructed_variable_declaration prefers the syntax 'var (x, y)' for deconstructing variables.
# Example:
# [TRUE]: var (x, y) = GetValues();
# [FALSE]
# (int x, int y) = GetValues();
csharp_style_deconstructed_variable_declaration = true:suggestion

# csharp_style_implicit_object_creation_when_type_is_apparent prefers using 'new()' in object creation when the type is known from context.
# Example:
# [TRUE]: List<int> numbers = new();
# [FALSE]: List<int> numbers = new List<int>();
csharp_style_implicit_object_creation_when_type_is_apparent = true:warning

# csharp_style_inlined_variable_declaration prefers declaring variables inline where they're used.
# Example:
# [TRUE]: if (int.TryParse(str, out int x)) { ... }
# [FALSE]
# int x;
# if (int.TryParse(str, out x)) { ... }
csharp_style_inlined_variable_declaration = true:warning

# csharp_style_prefer_index_operator prefers using the ^ operator for indexing from the end.
# Example:
# [TRUE]: var lastItem = array[^1];
# [FALSE]: var lastItem = array[array.Length - 1];
csharp_style_prefer_index_operator = true:suggestion

# csharp_style_prefer_local_over_anonymous_function prefers local functions to anonymous lambdas when possible.
# Example:
# [TRUE]: int Sum(int a, int b) => a + b;
# [FALSE]: Func<int, int, int> sum = (a, b) => a + b;
csharp_style_prefer_local_over_anonymous_function = true:warning

# csharp_style_prefer_null_check_over_type_check prefers '== null' or 'is null' checks rather than 'is SomeType'.
# Example:
# [TRUE]: if (obj is null) { ... }
# [FALSE]: if (!(obj is SomeType)) { ... } 
csharp_style_prefer_null_check_over_type_check = true:warning

# csharp_style_prefer_range_operator prefers using the .. operator for slicing.
# Example:
# [TRUE]: var slice = array[1..3];
# [FALSE]: var slice = array.Skip(1).Take(2);
csharp_style_prefer_range_operator = true:warning

# csharp_style_prefer_tuple_swap prefers the tuple swap (x, y) = (y, x) instead of temp variables.
# Example:
# [TRUE]: (x, y) = (y, x);
# [FALSE]
# var temp = x;
# x = y;
# y = temp;
csharp_style_prefer_tuple_swap = true:warning

# csharp_style_prefer_utf8_string_literals prefers the 'u8' suffix for UTF-8 string literals in C# 11+.
# Example:
# [TRUE]: "Hello"u8
# [FALSE]: Encoding.UTF8.GetBytes("Hello")
csharp_style_prefer_utf8_string_literals = true:warning

# csharp_style_throw_expression prefers the throw expression form in place of separate if checks.
# Example:
# [TRUE]: var person = value ?? throw new ArgumentNullException(nameof(value));
# [FALSE]
# if (value == null) throw new ArgumentNullException(nameof(value));
csharp_style_throw_expression = true:warning

# csharp_style_unused_value_assignment_preference defines how to handle unused value assignments (discard or unused local).
# Example:
# Option 1: _ = SomeMethod();
# Option 2: var x = SomeMethod(); // x is never used
csharp_style_unused_value_assignment_preference = discard_variable:suggestion

# csharp_style_unused_value_expression_statement_preference defines how to handle unused value expression statements (discard or remove).
# Example:
# Option 1: _ = SomeMethod();
# Option 2: SomeMethod(); // if it's not used
csharp_style_unused_value_expression_statement_preference = discard_variable:warning

# csharp_using_directive_placement enforces the placement of 'using' directives (inside or outside namespace).
# Example:
# Option 1 (outside_namespace):
# using System;
# namespace MyNamespace;
# Option 2 (inside_namespace):
# namespace MyNamespace
# {
#     using System;
# }
csharp_using_directive_placement = outside_namespace:warning

# csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental allows or disallows blank lines after colon in constructor initializers.
# Example:
# [TRUE]
# public MyClass() :
# 
#     base() { }
# [FALSE]: no blank lines
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true

# csharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental allows or disallows blank lines after => token.
# Example:
# [TRUE]
# public int GetValue() =>
# 
#     42;
# [FALSE]: no blank line
csharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true

# csharp_style_allow_blank_line_after_token_in_conditional_expression_experimental allows blank lines in ternary expressions after ? or :.
# Example:
# [TRUE]
# var result = condition ?
# 
#     "Yes" :
# 
#     "No";
# [FALSE]: no blank lines
csharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true

# csharp_style_allow_blank_lines_between_consecutive_braces_experimental allows or disallows blank lines between braces.
# Example:
# [TRUE]
# {
# 
#     {
#     }
# }
# [FALSE]: no blank lines
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = false:warning

# csharp_style_allow_embedded_statements_on_same_line_experimental allows or disallows embedded statements on the same line.
# Example:
# [TRUE]
# if (x) { y++; } 
# [FALSE]
# if (x)
# {
#     y++;
# }
csharp_style_allow_embedded_statements_on_same_line_experimental = false:warning

#########################################
########## C# Formatting Rules ##########
#########################################

# csharp_new_line_before_catch enforces a new line before 'catch'.
# Example:
# [TRUE]
# try
# {
# }
# catch
# {
# }
# [FALSE]: try { } catch { }
csharp_new_line_before_catch = true:warning

# csharp_new_line_before_else enforces a new line before 'else'.
# Example:
# [TRUE]
# if (condition)
# {
# }
# else
# {
# }
# [FALSE]: if (condition) { } else { }
csharp_new_line_before_else = true:warning

# csharp_new_line_before_finally enforces a new line before 'finally'.
# Example:
# [TRUE]
# try
# {
# }
# finally
# {
# }
# [FALSE]: try { } finally { }
csharp_new_line_before_finally = true:warning

# csharp_new_line_before_members_in_anonymous_types enforces new lines before members in anonymous types.
# Example:
# [TRUE]: new { 
#     Name = "Alice", 
#     Age = 30 
# }
# [FALSE]: new { Name = "Alice", Age = 30 }
csharp_new_line_before_members_in_anonymous_types = true

# csharp_new_line_before_members_in_object_initializers enforces new lines before members in object initializers.
# Example:
# [TRUE]: new Person { 
#     Name = "Bob", 
#     Age = 20 
# }
# [FALSE]: new Person { Name = "Bob", Age = 20 }
csharp_new_line_before_members_in_object_initializers = true

# csharp_new_line_before_open_brace enforces a new line before opening braces in all possible constructs.
# Example:
# Option 1:
# if (condition)
# {
# }
# Option 2: if (condition) {
# }
csharp_new_line_before_open_brace = all

# csharp_new_line_between_query_expression_clauses enforces new lines between query clauses.
# Example:
# [TRUE]
# var result = from x in collection
#              where x > 0
#              select x;
# [FALSE]: from x in collection where x > 0 select x;
csharp_new_line_between_query_expression_clauses = true:warning

# csharp_indent_block_contents enforces indentation of block contents.
# Example:
# [TRUE]
# {
#     statement;
# }
# [FALSE]
# {
# statement;
# }
csharp_indent_block_contents = true:warning

# csharp_indent_braces controls whether braces are indented.
# Example:
# [TRUE]
# if (condition)
#     {
#         statement;
#     }
# [FALSE]
# if (condition)
# {
#     statement;
# }
csharp_indent_braces = false:warning

# csharp_indent_case_contents enforces indentation of switch case contents.
# Example:
# [TRUE]
# switch (value)
# {
#     case 1:
#         DoSomething();
#         break;
# }
# [FALSE]
# switch (value)
# {
# case 1:
#     DoSomething();
#     break;
# }
csharp_indent_case_contents = true:warning

# csharp_indent_case_contents_when_block enforces indentation when case sections use braces.
# Example:
# [TRUE]
# case 1:
# {
#     DoSomething();
#     break;
# }
csharp_indent_case_contents_when_block = true:warning

# csharp_indent_labels controls the indentation level of labels.
# Example:
# Option 1 (one_less_than_current):
#     labelName:
#         DoSomething();
# Option 2:
# labelName:
#     DoSomething();
csharp_indent_labels = one_less_than_current

# csharp_indent_switch_labels enforces indentation of switch labels (case/default).
# Example:
# [TRUE]
# switch (value)
# {
#     case 1:
#         break;
# }
# [FALSE]
# switch (value)
# {
# case 1:
#     break;
# }
csharp_indent_switch_labels = true:warning

# csharp_space_after_cast controls spacing after cast operators.
# Example:
# [TRUE]: (int) x
# [FALSE]: (int)x
csharp_space_after_cast = false

# csharp_space_after_colon_in_inheritance_clause controls spacing after ':' in base class or interface list.
# Example:
# [TRUE]: class Derived : Base
# [FALSE]: class Derived :Base
csharp_space_after_colon_in_inheritance_clause = true:warning

# csharp_space_after_comma controls spacing after commas.
# Example:
# [TRUE]: var tuple = (1, 2);
# [FALSE]: var tuple = (1,2);
csharp_space_after_comma = true:warning

# csharp_space_after_dot controls spacing after a dot.
# Example:
# [TRUE]: obj. Property
# [FALSE]: obj.Property
csharp_space_after_dot = false:warning

# csharp_space_after_keywords_in_control_flow_statements enforces spacing after if, for, while, etc.
# Example:
# [TRUE]: if (condition) { ... }
# [FALSE]: if(condition) { ... }
csharp_space_after_keywords_in_control_flow_statements = true:warning

# csharp_space_after_semicolon_in_for_statement enforces a space after semicolons in for statements.
# Example:
# [TRUE]: for (int i = 0; i < 10; i++)
# [FALSE]: for (int i = 0;i<10;i++)
csharp_space_after_semicolon_in_for_statement = true:warning

# csharp_space_around_binary_operators controls spacing around binary operators.
# Example:
# Option 1: a + b
# Option 2: a+b
csharp_space_around_binary_operators = before_and_after

# csharp_space_around_declaration_statements controls spacing around declaration statements (like local variables).
# Example:
# [TRUE]: int  x   =  0;
# [FALSE]: int x = 0;
csharp_space_around_declaration_statements = false:warning

# csharp_space_before_colon_in_inheritance_clause controls spacing before ':' in base class/interface list.
# Example:
# [TRUE]: class Derived : Base
# [FALSE]: class Derived: Base
csharp_space_before_colon_in_inheritance_clause = true:warning

# csharp_space_before_comma controls spacing before commas.
# Example:
# [TRUE]: (1 , 2)
# [FALSE]: (1, 2)
csharp_space_before_comma = false:warning

# csharp_space_before_dot controls spacing before a dot.
# Example:
# [TRUE]: obj .Property
# [FALSE]: obj.Property
csharp_space_before_dot = false:warning

# csharp_space_before_open_square_brackets controls spacing before '[' in attributes or indexers.
# Example:
# [TRUE]: [ Obsolete]
# [FALSE]: [Obsolete]
csharp_space_before_open_square_brackets = false:warning

# csharp_space_before_semicolon_in_for_statement controls spacing before semicolons in for statements.
# Example:
# [TRUE]: for (int i = 0 ; i < 10 ; i++)
# [FALSE]: for (int i = 0; i < 10; i++)
csharp_space_before_semicolon_in_for_statement = false:warning

# csharp_space_between_empty_square_brackets controls spacing between empty brackets [].
# Example:
# [TRUE]: new int[ 0 ]
# [FALSE]: new int[0]
csharp_space_between_empty_square_brackets = false:warning

# csharp_space_between_method_call_empty_parameter_list_parentheses controls spacing in empty parameter lists.
# Example:
# [TRUE]: Method( )
# [FALSE]: Method()
csharp_space_between_method_call_empty_parameter_list_parentheses = false:warning

# csharp_space_between_method_call_name_and_opening_parenthesis controls spacing between method name and '('.
# Example:
# Option 1: Method(arg)
# [TRUE]: Method (arg)
csharp_space_between_method_call_name_and_opening_parenthesis = false:warning

# csharp_space_between_method_call_parameter_list_parentheses controls spacing within parameter parentheses.
# Example:
# Option 1: Method(a, b)
# [TRUE]: Method(a,b)
csharp_space_between_method_call_parameter_list_parentheses = false:warning

# csharp_space_between_method_declaration_empty_parameter_list_parentheses controls spacing in empty parameter lists for methods.
# Example:
# Option 1: void Method()
# [TRUE]: void Method( )
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false:warning

# csharp_space_between_method_declaration_name_and_open_parenthesis controls spacing between method name and '('.
# Example:
# Option 1: void Method(string x)
# [TRUE]: void Method (string x)
csharp_space_between_method_declaration_name_and_open_parenthesis = false:warning

# csharp_space_between_method_declaration_parameter_list_parentheses controls spacing within method parameter parentheses.
# Example:
# Option 1: void Method(int x, int y)
# [TRUE]: void Method(int x,int y)
csharp_space_between_method_declaration_parameter_list_parentheses = false:warning

# csharp_space_between_parentheses controls spacing inside parentheses in expressions.
# Example:
# Option 1: (x + y)
# [TRUE]: ( x + y )
csharp_space_between_parentheses = false:warning

# csharp_space_between_square_brackets controls spacing inside square brackets.
# Example:
# Option 1: array[0]
# [TRUE]: array[ 0 ]
csharp_space_between_square_brackets = false:warning

# csharp_preserve_single_line_blocks controls whether single-line blocks are kept on one line.
# Example:
# [TRUE]
# if (condition) { DoSomething(); }
# (if consistent with other styles)
csharp_preserve_single_line_blocks = true

# csharp_preserve_single_line_statements controls whether single-line statements remain on one line.
# Example:
# [TRUE]: if (condition) DoSomething();
# if consistent with style
csharp_preserve_single_line_statements = true

###################################
########## Naming styles ##########
###################################

# dotnet_naming_rule.interface_should_be_begins_with_i enforces interface names start with 'I'.
# Example:
# Option 1: public interface IMyInterface { }
# Option 2: public interface MyInterface { }
dotnet_naming_rule.interface_should_be_begins_with_i.severity = warning
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

# dotnet_naming_rule.types_should_be_pascal_case ensures types (class, struct, enum, interface) follow PascalCase.
# Example:
# Option 1: public class MyClass { }
# Option 2: public class myClass { }
dotnet_naming_rule.types_should_be_pascal_case.severity = warning
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

# dotnet_naming_rule.non_field_members_should_be_pascal_case ensures non-field members (properties, events, methods) follow PascalCase.
# Example:
# Option 1: public void MyMethod() { }
# Option 2: public void myMethod() { }
dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# dotnet_naming_symbols.interface defines the symbols considered 'interface'.
dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers = 

# dotnet_naming_symbols.types defines the symbols considered 'types'.
dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers = 

# dotnet_naming_symbols.non_field_members defines property, event, and method symbols.
dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers = 

# dotnet_naming_style.pascal_case configures PascalCase naming.
dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case

# dotnet_naming_style.begins_with_i configures naming style that begins with 'I' and then uses PascalCase.
dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case

# trim_trailing_whitespace enforces removing trailing whitespace at end of lines.
# Example:
# [TRUE]: "Line with no trailing spaces"
# [FALSE]: "Line with trailing spaces   "
trim_trailing_whitespace = true:warning

# dotnet_diagnostic.IDE0005.severity configures severity for unnecessary usings (Roslyn analyzers).
# Example: 
# Option 1: using System; // if actually needed
# Option 2: using System; // if not used
dotnet_diagnostic.IDE0005.severity = warning

# All naming options have rule ID IDE1006 and title Naming rule violation. 
# IDE1006 sets how strict the IDE enforces naming violations
# CURRENTLY NOT FULLY SUPPORTED
# ERROR MESSAGE: Unable to fix IDE1006. Code fix NamingStyleCodeFixProvider doesn't support Fix All in Solution
dotnet_diagnostic.IDE1006.severity = suggestion

# dotnet_diagnostic.CS8019.severity configures severity for unnecessary usings (C# compiler).
# Example:
# Option 1: remove unused usings
# Option 2: keep them
dotnet_diagnostic.CS8019.severity = silent

# dotnet_diagnostic.IDE0079.severity configures severity for redundant suppression of diagnostics.
# Example:
# Option 1: no redundant #pragma
# Option 2: #pragma warning disable IDE0005 without reason
dotnet_diagnostic.IDE0079.severity = warning

# dotnet_diagnostic.IDE0130.severity configures severity for inconsistent nameof usage.
# Example:
# Option 1: throw new ArgumentNullException(nameof(parameterName));
# Option 2: throw new ArgumentNullException("parameterName");
# CURRENTLY CAUSES A System.NotSupportedException WHEN SET TO "warning"
dotnet_diagnostic.IDE0130.severity = suggestion

# dotnet_diagnostic.CS1591.severity configures severity for missing XML comment warnings.
# Example:
# Option 1: /// <summary>Some doc</summary>
# Option 2: // no documentation
dotnet_diagnostic.CS1591.severity = silent

# csharp_prefer_system_threading_lock enforces using lock keyword from System.Threading (i.e., 'lock') where appropriate.
# Example:
# [TRUE]: lock (locker) { ... }
# [FALSE]: Monitor.Enter(locker); // manually
csharp_prefer_system_threading_lock = true:suggestion

[*.{cs,vb}]

# dotnet_style_coalesce_expression prefers ?? operator for null checks.
# Example:
# [TRUE]: var result = value ?? "default";
# [FALSE]: var result = value != null ? value : "default";
dotnet_style_coalesce_expression = true:warning

# dotnet_style_null_propagation prefers ?. null propagation over explicit null checks.
# Example:
# [TRUE]: var length = str?.Length;
# [FALSE]: var length = str == null ? 0 : str.Length;
dotnet_style_null_propagation = true:warning

# dotnet_style_prefer_is_null_check_over_reference_equality_method prefers 'is null' over ReferenceEquals(obj, null).
# Example:
# [TRUE] if (obj is null) { ... }
# [FALSE]: if (ReferenceEquals(obj, null)) { ... }
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:warning

# dotnet_style_prefer_auto_properties prefers auto-properties over backing fields.
# Example:
# [TRUE]:
# public int Age { get; set; }
# [FALSE]
# private int _age;
# public int Age { get => _age; set => _age = value; }
dotnet_style_prefer_auto_properties = true:silent

# dotnet_style_operator_placement_when_wrapping sets operator placement when breaking lines.
# Example:
# Option 1 (beginning_of_line):
# var sum = a
#     + b
#     + c;
dotnet_style_operator_placement_when_wrapping = beginning_of_line

# tab_width sets the number of spaces per tab if used.
tab_width = 4

# indent_size sets the size of an indentation.
indent_size = 4

# end_of_line enforces line ending style.
end_of_line = crlf

# dotnet_style_object_initializer prefers object initializers when possible.
# Example:
# [TRUE]: new Person { Name = "Alice" }
# [FALSE]: var person = new Person(); person.Name = "Alice";
dotnet_style_object_initializer = true:suggestion

# dotnet_style_collection_initializer prefers collection initializers when possible.
# Example:
# [TRUE]: var list = new List<int> { 1, 2 };
# [FALSE]: var list = new List<int>(); list.Add(1); list.Add(2);
dotnet_style_collection_initializer = true:suggestion

# dotnet_style_prefer_simplified_boolean_expressions prefers shorter boolean checks.
# Example:
# [TRUE]: if (flag) { ... }
# [FALSE]: if (flag == true) { ... }
dotnet_style_prefer_simplified_boolean_expressions = true:warning